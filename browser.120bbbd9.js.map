{"mappings":"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","sources":["<anon>","examples/browser/main.js","node_modules/@parcel/runtime-js/lib/runtime-c53d245d2a3b6193.js","src/sobel.ts","src/types.ts"],"sourcesContent":["\nfunction $parcel$interopDefault(a) {\n  return a && a.__esModule ? a.default : a;\n}\nvar $58d3c146ec73476f$exports = {};\n$58d3c146ec73476f$exports = import.meta.resolve(\"fGekV\");\n\n\n/**\n * Browser-specific ImageData factory\n */ class $08b0af2b5ec937a8$export$9e90345751a46d63 {\n    create(data, width, height) {\n        // In browser environment, use the native ImageData constructor\n        if (typeof ImageData !== 'undefined') return new ImageData(data, width, height);\n        throw new Error('ImageData is not supported in this environment');\n    }\n}\nclass $08b0af2b5ec937a8$export$3363deefedd4de2d {\n    create(data, width, height) {\n        // In Node.js, return a simple object that matches the interface\n        return {\n            data: data,\n            width: width,\n            height: height,\n            colorSpace: 'srgb'\n        };\n    }\n}\nfunction $08b0af2b5ec937a8$export$762a5ace79b2b6a7() {\n    if (typeof ImageData !== 'undefined') return new $08b0af2b5ec937a8$export$9e90345751a46d63();\n    return new $08b0af2b5ec937a8$export$3363deefedd4de2d();\n}\n\n\nclass $8e8446394e6011e0$export$8d63015e70a599d0 {\n    /**\n     * Constructor stores image dimensions, kernel size, and computes grayscale version\n     * @param imageData - original image data (browser ImageData or Node.js buffer)\n     * @param kernelSize - size of the Sobel kernel (3 or 5, defaults to 3)\n     */ constructor(imageData, kernelSize = 3){\n        this.imageData = imageData;\n        this.width = imageData.width;\n        this.height = imageData.height;\n        this.kernelSize = kernelSize;\n        this.grayscaleData = this.convertToGrayscale(imageData);\n    }\n    /**\n     * Safely retrieves the value of a specific pixel channel in an image array\n     * @param data - image pixel array\n     * @param x - horizontal coordinate\n     * @param y - vertical coordinate\n     * @param channel - 0=R, 1=G, 2=B, 3=A (default 0)\n     * @returns pixel channel value (0 if out of bounds)\n     */ pixelAt(data, x, y, channel = 0) {\n        if (x < 0 || x >= this.width || y < 0 || y >= this.height) return 0;\n        return data[(y * this.width + x) * 4 + channel];\n    }\n    /**\n     * Converts RGBA input to grayscale (preserves alpha as 255)\n     * @param imageData - original image data\n     * @returns new Uint8ClampedArray of grayscale RGBA pixels\n     */ convertToGrayscale(imageData) {\n        const gray = new Uint8ClampedArray(this.width * this.height * 4);\n        const src = imageData.data;\n        for(let i = 0; i < src.length; i += 4){\n            // Average of R, G, B channels\n            const avg = (src[i] + src[i + 1] + src[i + 2]) / 3;\n            gray[i] = gray[i + 1] = gray[i + 2] = avg; // Set R, G, B to avg\n            gray[i + 3] = 255; // Alpha remains fully opaque\n        }\n        return gray;\n    }\n    /**\n     * Applies Sobel filter using the specified kernel size and output format\n     * @param format - Output format ('magnitude', 'x', 'y', or 'direction')\n     * @returns ImageData with edge intensities\n     */ apply(format = 'magnitude') {\n        const output = new Uint8ClampedArray(this.width * this.height * 4);\n        const kernelRadius = Math.floor(this.kernelSize / 2);\n        // Select appropriate kernels based on size\n        const kernelX = this.kernelSize === 3 ? $8e8446394e6011e0$export$8d63015e70a599d0.kernelX3 : $8e8446394e6011e0$export$8d63015e70a599d0.kernelX5;\n        const kernelY = this.kernelSize === 3 ? $8e8446394e6011e0$export$8d63015e70a599d0.kernelY3 : $8e8446394e6011e0$export$8d63015e70a599d0.kernelY5;\n        for(let y = 0; y < this.height; y++)for(let x = 0; x < this.width; x++){\n            let gx = 0;\n            let gy = 0;\n            // Adjust loop based on kernelRadius\n            for(let ky = -kernelRadius; ky <= kernelRadius; ky++)for(let kx = -kernelRadius; kx <= kernelRadius; kx++){\n                const px = x + kx;\n                const py = y + ky;\n                // Adjust kernel index based on radius\n                const weightX = kernelX[ky + kernelRadius][kx + kernelRadius];\n                const weightY = kernelY[ky + kernelRadius][kx + kernelRadius];\n                const value = this.pixelAt(this.grayscaleData, px, py);\n                gx += value * weightX;\n                gy += value * weightY;\n            }\n            // Compute the output value based on the selected format\n            let value;\n            switch(format){\n                case 'x':\n                    value = Math.abs(gx);\n                    break;\n                case 'y':\n                    value = Math.abs(gy);\n                    break;\n                case 'direction':\n                    const angle = Math.atan2(gy, gx); // Angle in radians [-PI, PI]\n                    value = (angle + Math.PI) / (2 * Math.PI) * 255; // Map to [0, 255]\n                    break;\n                case 'magnitude':\n                default:\n                    value = Math.sqrt(gx * gx + gy * gy);\n                    break;\n            }\n            // Write the result as grayscale pixel in output\n            const index = (y * this.width + x) * 4;\n            output[index] = output[index + 1] = output[index + 2] = value;\n            output[index + 3] = 255; // Alpha remains opaque\n        }\n        // Create new ImageData object using the appropriate factory\n        return $8e8446394e6011e0$export$8d63015e70a599d0.imageDataFactory.create(output, this.width, this.height);\n    }\n}\n// ImageData factory for the current environment\n$8e8446394e6011e0$export$8d63015e70a599d0.imageDataFactory = (0, $08b0af2b5ec937a8$export$762a5ace79b2b6a7)();\n// Sobel kernel for detecting horizontal edges\n$8e8446394e6011e0$export$8d63015e70a599d0.kernelX3 = [\n    [\n        -1,\n        0,\n        1\n    ],\n    [\n        -2,\n        0,\n        2\n    ],\n    [\n        -1,\n        0,\n        1\n    ]\n];\n// Sobel kernel for detecting vertical edges\n$8e8446394e6011e0$export$8d63015e70a599d0.kernelY3 = [\n    [\n        -1,\n        -2,\n        -1\n    ],\n    [\n        0,\n        0,\n        0\n    ],\n    [\n        1,\n        2,\n        1\n    ]\n];\n// Add standard 5x5 Sobel kernels\n$8e8446394e6011e0$export$8d63015e70a599d0.kernelX5 = [\n    [\n        -1,\n        -2,\n        0,\n        2,\n        1\n    ],\n    [\n        -4,\n        -8,\n        0,\n        8,\n        4\n    ],\n    [\n        -6,\n        -12,\n        0,\n        12,\n        6\n    ],\n    [\n        -4,\n        -8,\n        0,\n        8,\n        4\n    ],\n    [\n        -1,\n        -2,\n        0,\n        2,\n        1\n    ]\n];\n$8e8446394e6011e0$export$8d63015e70a599d0.kernelY5 = [\n    [\n        -1,\n        -4,\n        -6,\n        -4,\n        -1\n    ],\n    [\n        -2,\n        -8,\n        -12,\n        -8,\n        -2\n    ],\n    [\n        0,\n        0,\n        0,\n        0,\n        0\n    ],\n    [\n        2,\n        8,\n        12,\n        8,\n        2\n    ],\n    [\n        1,\n        4,\n        6,\n        4,\n        1\n    ]\n];\n\n\ndocument.addEventListener('DOMContentLoaded', ()=>{\n    const imageUpload = document.getElementById('imageUpload');\n    const originalCanvas = document.getElementById('originalCanvas');\n    const sobelCanvas = document.getElementById('sobelCanvas');\n    const processButton = document.getElementById('processButton');\n    const outputFormat = document.getElementById('outputFormat');\n    const scaleSlider = document.getElementById('scale');\n    const scaleValue = document.getElementById('scaleValue');\n    const fileName = document.getElementById('fileName');\n    const dropZone = document.getElementById('dropZone');\n    const originalPlaceholder = document.getElementById('originalPlaceholder');\n    const edgePlaceholder = document.getElementById('edgePlaceholder');\n    const processingIndicator = document.getElementById('processingIndicator');\n    const downloadOriginal = document.getElementById('downloadOriginal');\n    const downloadEdges = document.getElementById('downloadEdges');\n    const kernelSizeSelect = document.getElementById('kernelSize');\n    let currentImage = null;\n    // Update scale value display\n    scaleSlider.addEventListener('input', ()=>{\n        scaleValue.textContent = scaleSlider.value;\n    });\n    // File input handling\n    imageUpload.addEventListener('change', handleFileSelect);\n    // Drag and drop handling\n    dropZone.addEventListener('dragover', (e)=>{\n        e.preventDefault();\n        dropZone.classList.add('drag-over');\n    });\n    dropZone.addEventListener('dragleave', ()=>{\n        dropZone.classList.remove('drag-over');\n    });\n    dropZone.addEventListener('drop', (e)=>{\n        e.preventDefault();\n        dropZone.classList.remove('drag-over');\n        if (e.dataTransfer.files.length) {\n            imageUpload.files = e.dataTransfer.files;\n            handleFileSelect();\n        }\n    });\n    processButton.addEventListener('click', processImage);\n    downloadOriginal.addEventListener('click', ()=>{\n        downloadCanvas(originalCanvas, 'original-image.png');\n    });\n    downloadEdges.addEventListener('click', ()=>{\n        downloadCanvas(sobelCanvas, 'edge-detection.png');\n    });\n    function handleFileSelect() {\n        const file = imageUpload.files[0];\n        if (file && file.type.match('image.*')) {\n            fileName.textContent = file.name;\n            const reader = new FileReader();\n            reader.onload = (e)=>{\n                const img = new Image();\n                img.onload = ()=>{\n                    // Display original image\n                    originalCanvas.width = img.width;\n                    originalCanvas.height = img.height;\n                    const ctxOriginal = originalCanvas.getContext('2d');\n                    ctxOriginal.drawImage(img, 0, 0);\n                    // Show canvas, hide placeholder\n                    originalCanvas.classList.remove('hidden');\n                    originalPlaceholder.classList.add('hidden');\n                    // Enable process button\n                    processButton.disabled = false;\n                    downloadOriginal.disabled = false;\n                    // Store current image\n                    currentImage = img;\n                };\n                img.src = e.target.result;\n            };\n            reader.readAsDataURL(file);\n        }\n    }\n    function processImage() {\n        if (!currentImage) return;\n        // Hide edge canvas and show loading indicator\n        sobelCanvas.classList.add('hidden');\n        edgePlaceholder.classList.add('hidden');\n        processingIndicator.classList.remove('hidden');\n        downloadEdges.disabled = true;\n        // Get options, including kernel size\n        const options = {\n            outputFormat: outputFormat.value,\n            kernelSize: parseInt(kernelSizeSelect.value, 10),\n            scale: parseFloat(scaleSlider.value)\n        };\n        // Process the image using our Sobel library\n        applySobelFilter(currentImage, sobelCanvas, options);\n        // Hide loading indicator, show result\n        processingIndicator.classList.add('hidden');\n        sobelCanvas.classList.remove('hidden');\n        downloadEdges.disabled = false;\n    }\n    function applySobelFilter(image, canvas, options) {\n        canvas.width = image.width;\n        canvas.height = image.height;\n        const ctx = canvas.getContext('2d');\n        // Draw original image\n        ctx.drawImage(image, 0, 0);\n        // Get image data\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\n        // Apply Sobel edge detection with selected output format\n        const sobel = new (0, $8e8446394e6011e0$export$8d63015e70a599d0)(imageData, options.kernelSize);\n        const edgeImageData = sobel.apply(options.outputFormat);\n        // Apply scale factor\n        const data = edgeImageData.data;\n        for(let i = 0; i < data.length; i += 4){\n            data[i] = Math.min(255, data[i] * options.scale);\n            data[i + 1] = Math.min(255, data[i + 1] * options.scale);\n            data[i + 2] = Math.min(255, data[i + 2] * options.scale);\n        }\n        // Put processed data back\n        ctx.putImageData(edgeImageData, 0, 0);\n    }\n    function downloadCanvas(canvas, filename) {\n        const link = document.createElement('a');\n        link.download = filename;\n        link.href = canvas.toDataURL('image/png');\n        document.body.appendChild(link);\n        link.click();\n        document.body.removeChild(link);\n    }\n    // Load the default pug image\n    const defaultImg = new Image();\n    defaultImg.onload = ()=>{\n        originalCanvas.width = defaultImg.width;\n        originalCanvas.height = defaultImg.height;\n        const ctxOriginal = originalCanvas.getContext('2d');\n        ctxOriginal.drawImage(defaultImg, 0, 0);\n        originalCanvas.classList.remove('hidden');\n        originalPlaceholder.classList.add('hidden');\n        processButton.disabled = false;\n        downloadOriginal.disabled = false;\n        currentImage = defaultImg;\n    };\n    defaultImg.src = (0, (/*@__PURE__*/$parcel$interopDefault($58d3c146ec73476f$exports)));\n});\n\n\n//# sourceMappingURL=browser.120bbbd9.js.map\n","import pugImageUrl from 'url:./public/pug.png';\r\nimport { Sobel } from '../../src/sobel';\r\n\r\ndocument.addEventListener('DOMContentLoaded', () => {\r\n    const imageUpload = document.getElementById('imageUpload');\r\n    const originalCanvas = document.getElementById('originalCanvas');\r\n    const sobelCanvas = document.getElementById('sobelCanvas');\r\n    const processButton = document.getElementById('processButton');\r\n    const outputFormat = document.getElementById('outputFormat');\r\n    const scaleSlider = document.getElementById('scale');\r\n    const scaleValue = document.getElementById('scaleValue');\r\n    const fileName = document.getElementById('fileName');\r\n    const dropZone = document.getElementById('dropZone');\r\n    const originalPlaceholder = document.getElementById('originalPlaceholder');\r\n    const edgePlaceholder = document.getElementById('edgePlaceholder');\r\n    const processingIndicator = document.getElementById('processingIndicator');\r\n    const downloadOriginal = document.getElementById('downloadOriginal');\r\n    const downloadEdges = document.getElementById('downloadEdges');\r\n    const kernelSizeSelect = document.getElementById('kernelSize');\r\n    \r\n    let currentImage = null;\r\n    \r\n    // Update scale value display\r\n    scaleSlider.addEventListener('input', () => {\r\n        scaleValue.textContent = scaleSlider.value;\r\n    });\r\n    \r\n    // File input handling\r\n    imageUpload.addEventListener('change', handleFileSelect);\r\n    \r\n    // Drag and drop handling\r\n    dropZone.addEventListener('dragover', (e) => {\r\n        e.preventDefault();\r\n        dropZone.classList.add('drag-over');\r\n    });\r\n    \r\n    dropZone.addEventListener('dragleave', () => {\r\n        dropZone.classList.remove('drag-over');\r\n    });\r\n    \r\n    dropZone.addEventListener('drop', (e) => {\r\n        e.preventDefault();\r\n        dropZone.classList.remove('drag-over');\r\n        \r\n        if (e.dataTransfer.files.length) {\r\n            imageUpload.files = e.dataTransfer.files;\r\n            handleFileSelect();\r\n        }\r\n    });\r\n    \r\n    processButton.addEventListener('click', processImage);\r\n    \r\n    downloadOriginal.addEventListener('click', () => {\r\n        downloadCanvas(originalCanvas, 'original-image.png');\r\n    });\r\n    \r\n    downloadEdges.addEventListener('click', () => {\r\n        downloadCanvas(sobelCanvas, 'edge-detection.png');\r\n    });\r\n    \r\n    function handleFileSelect() {\r\n        const file = imageUpload.files[0];\r\n        \r\n        if (file && file.type.match('image.*')) {\r\n            fileName.textContent = file.name;\r\n            \r\n            const reader = new FileReader();\r\n            \r\n            reader.onload = (e) => {\r\n                const img = new Image();\r\n                img.onload = () => {\r\n                    // Display original image\r\n                    originalCanvas.width = img.width;\r\n                    originalCanvas.height = img.height;\r\n                    const ctxOriginal = originalCanvas.getContext('2d');\r\n                    ctxOriginal.drawImage(img, 0, 0);\r\n                    \r\n                    // Show canvas, hide placeholder\r\n                    originalCanvas.classList.remove('hidden');\r\n                    originalPlaceholder.classList.add('hidden');\r\n                    \r\n                    // Enable process button\r\n                    processButton.disabled = false;\r\n                    downloadOriginal.disabled = false;\r\n                    \r\n                    // Store current image\r\n                    currentImage = img;\r\n                };\r\n                img.src = e.target.result;\r\n            };\r\n            \r\n            reader.readAsDataURL(file);\r\n        }\r\n    }\r\n    \r\n    function processImage() {\r\n        if (!currentImage) return;\r\n        \r\n        // Hide edge canvas and show loading indicator\r\n        sobelCanvas.classList.add('hidden');\r\n        edgePlaceholder.classList.add('hidden');\r\n        processingIndicator.classList.remove('hidden');\r\n        downloadEdges.disabled = true;\r\n        \r\n        // Get options, including kernel size\r\n        const options = {\r\n            outputFormat: outputFormat.value,\r\n            kernelSize: parseInt(kernelSizeSelect.value, 10),\r\n            scale: parseFloat(scaleSlider.value)\r\n        };\r\n        \r\n        // Process the image using our Sobel library\r\n        applySobelFilter(currentImage, sobelCanvas, options);\r\n        \r\n        // Hide loading indicator, show result\r\n        processingIndicator.classList.add('hidden');\r\n        sobelCanvas.classList.remove('hidden');\r\n        downloadEdges.disabled = false;\r\n    }\r\n    \r\n    function applySobelFilter(image, canvas, options) {\r\n        canvas.width = image.width;\r\n        canvas.height = image.height;\r\n        const ctx = canvas.getContext('2d');\r\n        \r\n        // Draw original image\r\n        ctx.drawImage(image, 0, 0);\r\n        \r\n        // Get image data\r\n        const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);\r\n        \r\n        // Apply Sobel edge detection with selected output format\r\n        const sobel = new Sobel(imageData, options.kernelSize);\r\n        const edgeImageData = sobel.apply(options.outputFormat);\r\n        \r\n        // Apply scale factor\r\n        const data = edgeImageData.data;\r\n        for (let i = 0; i < data.length; i += 4) {\r\n            data[i] = Math.min(255, data[i] * options.scale);\r\n            data[i + 1] = Math.min(255, data[i + 1] * options.scale);\r\n            data[i + 2] = Math.min(255, data[i + 2] * options.scale);\r\n        }\r\n        \r\n        // Put processed data back\r\n        ctx.putImageData(edgeImageData, 0, 0);\r\n    }\r\n    \r\n    function downloadCanvas(canvas, filename) {\r\n        const link = document.createElement('a');\r\n        link.download = filename;\r\n        link.href = canvas.toDataURL('image/png');\r\n        document.body.appendChild(link);\r\n        link.click();\r\n        document.body.removeChild(link);\r\n    }\r\n\r\n    // Load the default pug image\r\n    const defaultImg = new Image();\r\n    defaultImg.onload = () => {\r\n        originalCanvas.width = defaultImg.width;\r\n        originalCanvas.height = defaultImg.height;\r\n        const ctxOriginal = originalCanvas.getContext('2d');\r\n        ctxOriginal.drawImage(defaultImg, 0, 0);\r\n        \r\n        originalCanvas.classList.remove('hidden');\r\n        originalPlaceholder.classList.add('hidden');\r\n        processButton.disabled = false;\r\n        downloadOriginal.disabled = false;\r\n        \r\n        currentImage = defaultImg;\r\n    };\r\n    defaultImg.src = pugImageUrl;\r\n}); ","module.exports = __parcel__import__.meta.resolve(\"fGekV\");","import { getImageDataFactory, ImageDataLike, KernelSize, OutputFormat } from './types';\n\n/**\n * Converts ImageData to grayscale, applies Sobel kernels, returns new ImageData\n * \n * This class performs edge detection using the Sobel operator.\n * It processes a given ImageData object to extract horizontal and vertical gradients,\n * then outputs a new ImageData with edge intensities encoded as grayscale values.\n * \n * This is a TypeScript implementation with enhancements including:\n * - Variable kernel sizes (3x3, 5x5)\n * - Multiple output formats (magnitude, x, y, direction)\n * \n * Current Maintainer/Developer: @catorch\n * \n * This work builds upon the original JavaScript version by Miguel Mota\n * (https://github.com/miguelmota/sobel, MIT License).\n * \n */\nexport class Sobel {\n    // Dimensions of the input image\n    private width: number;\n    private height: number;\n    // Stores the grayscale-converted image data\n    private grayscaleData: Uint8ClampedArray;\n    // ImageData factory for the current environment\n    private static imageDataFactory = getImageDataFactory();\n    private kernelSize: KernelSize;\n  \n    // Sobel kernel for detecting horizontal edges\n    private static kernelX3 = [\n      [-1, 0, 1],\n      [-2, 0, 2],\n      [-1, 0, 1],\n    ];\n  \n    // Sobel kernel for detecting vertical edges\n    private static kernelY3 = [\n      [-1, -2, -1],\n      [ 0,  0,  0],\n      [ 1,  2,  1],\n    ];\n  \n    // Add standard 5x5 Sobel kernels\n    private static kernelX5 = [\n        [-1, -2, 0, 2, 1],\n        [-4, -8, 0, 8, 4],\n        [-6,-12, 0,12, 6],\n        [-4, -8, 0, 8, 4],\n        [-1, -2, 0, 2, 1]\n    ];\n    private static kernelY5 = [\n        [-1, -4, -6, -4, -1],\n        [-2, -8,-12, -8, -2],\n        [ 0,  0,  0,  0,  0],\n        [ 2,  8, 12,  8,  2],\n        [ 1,  4,  6,  4,  1]\n    ];\n  \n    /**\n     * Constructor stores image dimensions, kernel size, and computes grayscale version\n     * @param imageData - original image data (browser ImageData or Node.js buffer)\n     * @param kernelSize - size of the Sobel kernel (3 or 5, defaults to 3)\n     */\n    constructor(private imageData: ImageDataLike, kernelSize: KernelSize = 3) {\n      this.width = imageData.width;\n      this.height = imageData.height;\n      this.kernelSize = kernelSize;\n      this.grayscaleData = this.convertToGrayscale(imageData);\n    }\n  \n    /**\n     * Safely retrieves the value of a specific pixel channel in an image array\n     * @param data - image pixel array\n     * @param x - horizontal coordinate\n     * @param y - vertical coordinate\n     * @param channel - 0=R, 1=G, 2=B, 3=A (default 0)\n     * @returns pixel channel value (0 if out of bounds)\n     */\n    private pixelAt(data: Uint8ClampedArray, x: number, y: number, channel: number = 0): number {\n      if (x < 0 || x >= this.width || y < 0 || y >= this.height) return 0;\n      return data[(y * this.width + x) * 4 + channel];\n    }\n  \n    /**\n     * Converts RGBA input to grayscale (preserves alpha as 255)\n     * @param imageData - original image data\n     * @returns new Uint8ClampedArray of grayscale RGBA pixels\n     */\n    private convertToGrayscale(imageData: ImageDataLike): Uint8ClampedArray {\n      const gray = new Uint8ClampedArray(this.width * this.height * 4);\n      const src = imageData.data;\n  \n      for (let i = 0; i < src.length; i += 4) {\n        // Average of R, G, B channels\n        const avg = (src[i] + src[i + 1] + src[i + 2]) / 3;\n        gray[i] = gray[i + 1] = gray[i + 2] = avg; // Set R, G, B to avg\n        gray[i + 3] = 255; // Alpha remains fully opaque\n      }\n  \n      return gray;\n    }\n  \n    /**\n     * Applies Sobel filter using the specified kernel size and output format\n     * @param format - Output format ('magnitude', 'x', 'y', or 'direction')\n     * @returns ImageData with edge intensities\n     */\n    public apply(format: OutputFormat = 'magnitude'): ImageDataLike {\n      const output = new Uint8ClampedArray(this.width * this.height * 4);\n      const kernelRadius = Math.floor(this.kernelSize / 2);\n  \n      // Select appropriate kernels based on size\n      const kernelX = this.kernelSize === 3 ? Sobel.kernelX3 : Sobel.kernelX5;\n      const kernelY = this.kernelSize === 3 ? Sobel.kernelY3 : Sobel.kernelY5;\n  \n      for (let y = 0; y < this.height; y++) {\n        for (let x = 0; x < this.width; x++) {\n          let gx = 0;\n          let gy = 0;\n  \n          // Adjust loop based on kernelRadius\n          for (let ky = -kernelRadius; ky <= kernelRadius; ky++) {\n            for (let kx = -kernelRadius; kx <= kernelRadius; kx++) {\n              const px = x + kx;\n              const py = y + ky;\n  \n              // Adjust kernel index based on radius\n              const weightX = kernelX[ky + kernelRadius][kx + kernelRadius];\n              const weightY = kernelY[ky + kernelRadius][kx + kernelRadius];\n  \n              const value = this.pixelAt(this.grayscaleData, px, py);\n  \n              gx += value * weightX;\n              gy += value * weightY;\n            }\n          }\n  \n          // Compute the output value based on the selected format\n          let value: number;\n          switch (format) {\n              case 'x':\n                  value = Math.abs(gx);\n                  break;\n              case 'y':\n                  value = Math.abs(gy);\n                  break;\n              case 'direction':\n                  const angle = Math.atan2(gy, gx); // Angle in radians [-PI, PI]\n                  value = ((angle + Math.PI) / (2 * Math.PI)) * 255; // Map to [0, 255]\n                  break;\n              case 'magnitude':\n              default:\n                  value = Math.sqrt(gx * gx + gy * gy);\n                  break;\n          }\n  \n          // Write the result as grayscale pixel in output\n          const index = (y * this.width + x) * 4;\n          output[index] = output[index + 1] = output[index + 2] = value;\n          output[index + 3] = 255; // Alpha remains opaque\n        }\n      }\n  \n      // Create new ImageData object using the appropriate factory\n      return Sobel.imageDataFactory.create(output, this.width, this.height);\n    }\n  }\n  ","/**\n * Defines a type for the supported output formats of the Sobel operator.\n */\nexport type OutputFormat = 'magnitude' | 'x' | 'y' | 'direction';\n\n/**\n * Defines the supported kernel sizes for the Sobel operator.\n */\nexport type KernelSize = 3 | 5;\n\n/**\n * Platform-agnostic interface for image data\n * Compatible with both browser's ImageData and Node.js buffers\n */\nexport interface ImageDataLike {\n  width: number;\n  height: number;\n  data: Uint8ClampedArray;\n  colorSpace?: string; // Optional to support older browsers\n}\n\n/**\n * Factory interface for creating ImageData objects\n */\nexport interface ImageDataFactory {\n  create(data: Uint8ClampedArray, width: number, height: number): ImageDataLike;\n}\n\n/**\n * Browser-specific ImageData factory\n */\nexport class BrowserImageDataFactory implements ImageDataFactory {\n  create(data: Uint8ClampedArray, width: number, height: number): ImageDataLike {\n    // In browser environment, use the native ImageData constructor\n    if (typeof ImageData !== 'undefined') {\n      return new ImageData(data, width, height);\n    }\n    throw new Error('ImageData is not supported in this environment');\n  }\n}\n\n/**\n * Node.js-specific ImageData factory\n */\nexport class NodeImageDataFactory implements ImageDataFactory {\n  create(data: Uint8ClampedArray, width: number, height: number): ImageDataLike {\n    // In Node.js, return a simple object that matches the interface\n    return {\n      data,\n      width,\n      height,\n      colorSpace: 'srgb'\n    };\n  }\n}\n\n/**\n * Get the appropriate ImageData factory for the current environment\n */\nexport function getImageDataFactory(): ImageDataFactory {\n  if (typeof ImageData !== 'undefined') {\n    return new BrowserImageDataFactory();\n  }\n  return new NodeImageDataFactory();\n} "],"names":["$58d3c146ec73476f$exports","resolve","$8e8446394e6011e0$export$8d63015e70a599d0","constructor","imageData","kernelSize","width","height","grayscaleData","convertToGrayscale","pixelAt","data","x","y","channel","gray","Uint8ClampedArray","src","i","length","avg","apply","format","output","kernelRadius","Math","floor","kernelX","kernelX3","kernelX5","kernelY","kernelY3","kernelY5","value","gx","gy","ky","kx","px","py","weightX","weightY","abs","angle","atan2","PI","sqrt","index","imageDataFactory","create","ImageData","$08b0af2b5ec937a8$export$9e90345751a46d63","Error","$08b0af2b5ec937a8$export$3363deefedd4de2d","colorSpace","document","addEventListener","a","imageUpload","getElementById","originalCanvas","sobelCanvas","processButton","outputFormat","scaleSlider","scaleValue","fileName","dropZone","originalPlaceholder","edgePlaceholder","processingIndicator","downloadOriginal","downloadEdges","kernelSizeSelect","currentImage","handleFileSelect","file","files","type","match","textContent","name","reader","FileReader","onload","e","img","Image","ctxOriginal","getContext","drawImage","classList","remove","add","disabled","target","result","readAsDataURL","downloadCanvas","canvas","filename","link","createElement","download","href","toDataURL","body","appendChild","click","removeChild","preventDefault","dataTransfer","options","parseInt","scale","parseFloat","applySobelFilter","image","ctx","edgeImageData","sobel","getImageData","min","putImageData","defaultImg","__esModule","default"],"version":3,"file":"browser.120bbbd9.js.map"}